import{b as T,c as h,m as x,h as K,d as v,i as c}from"./C_hR8wQP.js";import{s as y,t as l,b as g,n as U,S as _,f as I,a as p,c as L,d as M}from"./Dmwvy2AT.js";function b(s,e){return y.IntentMessage(y.fixedArray(e.length,y.u8())).serialize({intent:{scope:{[s]:!0},version:{V0:!0},appId:{Sui:!0}},value:e}).toBytes()}const S={ED25519:0,Secp256k1:1,Secp256r1:2,MultiSig:3,ZkLogin:5,Passkey:6},H={ED25519:32,Secp256k1:33,Secp256r1:33},A={0:"ED25519",1:"Secp256k1",2:"Secp256r1",3:"MultiSig",5:"ZkLogin",6:"Passkey"};function P(s,e){if(s===e)return!0;if(s.length!==e.length)return!1;for(let t=0;t<s.length;t++)if(s[t]!==e[t])return!1;return!0}class W{equals(e){return P(this.toRawBytes(),e.toRawBytes())}toBase64(){return l(this.toRawBytes())}toString(){throw new Error("`toString` is not implemented on public keys. Use `toBase64()` or `toRawBytes()` instead.")}toSuiPublicKey(){const e=this.toSuiBytes();return l(e)}verifyWithIntent(e,t,r){const n=b(r,e),i=g(n,{dkLen:32});return this.verify(i,t)}verifyPersonalMessage(e,t){return this.verifyWithIntent(y.vector(y.u8()).serialize(e).toBytes(),t,"PersonalMessage")}verifyTransaction(e,t){return this.verifyWithIntent(e,t,"TransactionData")}verifyAddress(e){return this.toSuiAddress()===e}toSuiBytes(){const e=this.toRawBytes(),t=new Uint8Array(e.length+1);return t.set([this.flag()]),t.set(e,1),t}toSuiAddress(){return U(T(g(this.toSuiBytes(),{dkLen:32})).slice(0,_*2))}}function C(s){const e=I(s),t=A[e[0]];switch(t){case"ED25519":case"Secp256k1":case"Secp256r1":const r=H[t],n=e.slice(1,e.length-r),i=e.slice(1+n.length);return{serializedSignature:s,signatureScheme:t,signature:n,publicKey:i,bytes:e};default:throw new Error("Unsupported signature scheme")}}function V({signature:s,signatureScheme:e,publicKey:t}){if(!t)throw new Error("`publicKey` is required");const r=t.toRawBytes(),n=new Uint8Array(1+s.length+r.length);return n.set([S[e]]),n.set(s,1),n.set(r,1+s.length),l(n)}const d=32,B="suiprivkey";class z{async signWithIntent(e,t){const r=b(t,e),n=g(r,{dkLen:32});return{signature:V({signature:await this.sign(n),signatureScheme:this.getKeyScheme(),publicKey:this.getPublicKey()}),bytes:l(e)}}async signTransaction(e){return this.signWithIntent(e,"TransactionData")}async signPersonalMessage(e){const{signature:t}=await this.signWithIntent(p.vector(p.u8()).serialize(e).toBytes(),"PersonalMessage");return{bytes:l(e),signature:t}}toSuiAddress(){return this.getPublicKey().toSuiAddress()}}class F extends z{}function N(s){const{prefix:e,words:t}=h.decode(s);if(e!==B)throw new Error("invalid private key prefix");const r=new Uint8Array(h.fromWords(t)),n=r.slice(1);return{schema:A[r[0]],secretKey:n}}function $(s,e){if(s.length!==d)throw new Error("Invalid bytes length");const t=S[e],r=new Uint8Array(s.length+1);return r.set([t]),r.set(s,1),h.encode(B,h.toWords(r))}function w(s){return!!new RegExp("^m\\/44'\\/784'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'+$").test(s)}function G(s){return x(s,"")}function Z(s){return L(G(s))}const q="ed25519 seed",O=2147483648,Y=new RegExp("^m(\\/[0-9]+')+$"),k=s=>s.replace("'",""),X=s=>{const t=K.create(v,q).update(M(s)).digest(),r=t.slice(0,32),n=t.slice(32);return{key:r,chainCode:n}},j=({key:s,chainCode:e},t)=>{const r=new ArrayBuffer(4);new DataView(r).setUint32(0,t);const i=new Uint8Array(1+s.length+r.byteLength);i.set(new Uint8Array(1).fill(0)),i.set(s,1),i.set(new Uint8Array(r,0,r.byteLength),s.length+1);const o=K.create(v,e).update(i).digest(),a=o.slice(0,32),D=o.slice(32);return{key:a,chainCode:D}},J=s=>Y.test(s)?!s.split("/").slice(1).map(k).some(isNaN):!1,E=(s,e,t=O)=>{if(!J(s))throw new Error("Invalid derivation path");const{key:r,chainCode:n}=X(e);return s.split("/").slice(1).map(k).map(o=>parseInt(o,10)).reduce((o,a)=>j(o,a+t),{key:r,chainCode:n})},f=32;class R extends W{constructor(e){if(super(),typeof e=="string"?this.data=I(e):e instanceof Uint8Array?this.data=e:this.data=Uint8Array.from(e),this.data.length!==f)throw new Error(`Invalid public key input. Expected ${f} bytes, got ${this.data.length}`)}equals(e){return super.equals(e)}toRawBytes(){return this.data}flag(){return S.ED25519}async verify(e,t){let r;if(typeof t=="string"){const n=C(t);if(n.signatureScheme!=="ED25519")throw new Error("Invalid signature scheme");if(!P(this.toRawBytes(),n.publicKey))throw new Error("Signature does not match public key");r=n.signature}else r=t;return c.verify(r,e,this.toRawBytes())}}R.SIZE=f;const m="m/44'/784'/0'/0'/0'";class u extends F{constructor(e){if(super(),e)this.keypair={publicKey:e.publicKey,secretKey:e.secretKey.slice(0,32)};else{const t=c.utils.randomPrivateKey();this.keypair={publicKey:c.getPublicKey(t),secretKey:t}}}getKeyScheme(){return"ED25519"}static generate(){const e=c.utils.randomPrivateKey();return new u({publicKey:c.getPublicKey(e),secretKey:e})}static fromSecretKey(e,t){if(typeof e=="string"){const i=N(e);if(i.schema!=="ED25519")throw new Error(`Expected a ED25519 keypair, got ${i.schema}`);return this.fromSecretKey(i.secretKey,t)}const r=e.length;if(r!==d)throw new Error(`Wrong secretKey size. Expected ${d} bytes, got ${r}.`);const n={publicKey:c.getPublicKey(e),secretKey:e};if(!t||!t.skipValidation){const o=new TextEncoder().encode("sui validation"),a=c.sign(o,e);if(!c.verify(a,o,n.publicKey))throw new Error("provided secretKey is invalid")}return new u(n)}getPublicKey(){return new R(this.keypair.publicKey)}getSecretKey(){return $(this.keypair.secretKey.slice(0,d),this.getKeyScheme())}async sign(e){return c.sign(e,this.keypair.secretKey)}static deriveKeypair(e,t){if(t==null&&(t=m),!w(t))throw new Error("Invalid derivation path");const{key:r}=E(t,Z(e));return u.fromSecretKey(r)}static deriveKeypairFromSeed(e,t){if(t==null&&(t=m),!w(t))throw new Error("Invalid derivation path");const{key:r}=E(t,e);return u.fromSecretKey(r)}}export{u as E};
