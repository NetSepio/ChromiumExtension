{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n\n  checkErrors([], result);\n  return errors;\n}\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  get data() {\n    return hexConcat(this._data);\n  }\n\n  get length() {\n    return this._dataLength;\n  }\n\n  _writeData(data) {\n    this._data.push(data);\n\n    this._dataLength += data.length;\n    return data.length;\n  }\n\n  appendWriter(writer) {\n    return this._writeData(concat(writer._data));\n  } // Arrayish items; padded on the right to wordSize\n\n\n  writeBytes(value) {\n    let bytes = arrayify(value);\n    const paddingOffset = bytes.length % this.wordSize;\n\n    if (paddingOffset) {\n      bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n    }\n\n    return this._writeData(bytes);\n  }\n\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n\n    return bytes;\n  } // BigNumberish items; padded on the left to wordSize\n\n\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n\n  writeUpdatableValue() {\n    const offset = this._data.length;\n\n    this._data.push(this._padding);\n\n    this._dataLength += this.wordSize;\n    return value => {\n      this._data[offset] = this._getValue(value);\n    };\n  }\n\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc, allowLoose) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n\n  get data() {\n    return hexlify(this._data);\n  }\n\n  get consumed() {\n    return this._offset;\n  } // The default Coerce function\n\n\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n\n    return value;\n  }\n\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n\n    return Reader.coerce(name, value);\n  }\n\n  _peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n    if (this._offset + alignedLength > this._data.length) {\n      if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n        alignedLength = length;\n      } else {\n        logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this._data.length,\n          offset: this._offset + alignedLength\n        });\n      }\n    }\n\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n  }\n\n  readBytes(length, loose) {\n    let bytes = this._peekBytes(0, length, !!loose);\n\n    this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n    return bytes.slice(0, length);\n  }\n\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n\n}","map":{"version":3,"sources":["/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@ethersproject/abi/src.ts/coders/abstract-coder.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\n\nexport interface Result extends ReadonlyArray<any> {\n    readonly [key: string]: any;\n}\n\nexport function checkResultErrors(result: Result): Array<{ path: Array<string | number>, error: Error }> {\n    // Find the first error (if any)\n    const errors: Array<{ path: Array<string | number>, error: Error }> = [ ];\n\n    const checkErrors = function(path: Array<string | number>, object: any): void {\n        if (!Array.isArray(object)) { return; }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n\n            try {\n                 checkErrors(childPath, object[key]);\n            } catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    }\n    checkErrors([ ], result);\n\n    return errors;\n\n}\n\nexport type CoerceFunc = (type: string, value: any) => any;\n\nexport abstract class Coder {\n\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    readonly name: string;\n\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    readonly type: string;\n\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    readonly localName: string;\n\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    readonly dynamic: boolean;\n\n    constructor(name: string, type: string, localName: string, dynamic: boolean) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n\n    _throwError(message: string, value: any): void {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n\n    abstract encode(writer: Writer, value: any): number;\n    abstract decode(reader: Reader): any;\n\n    abstract defaultValue(): any;\n}\n\nexport class Writer {\n    readonly wordSize: number;\n\n    _data: Array<Uint8Array>;\n    _dataLength: number;\n    _padding: Uint8Array;\n\n    constructor(wordSize?: number) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [ ];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n\n    get data(): string {\n        return hexConcat(this._data);\n    }\n    get length(): number { return this._dataLength; }\n\n    _writeData(data: Uint8Array): number {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n\n    appendWriter(writer: Writer): number {\n        return this._writeData(concat(writer._data));\n    }\n\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value: BytesLike): number {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([ bytes, this._padding.slice(paddingOffset) ])\n        }\n        return this._writeData(bytes);\n    }\n\n    _getValue(value: BigNumberish): Uint8Array {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([ this._padding.slice(bytes.length % this.wordSize), bytes ]);\n        }\n        return bytes;\n    }\n\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value: BigNumberish): number {\n        return this._writeData(this._getValue(value));\n    }\n\n    writeUpdatableValue(): (value: BigNumberish) => void {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value: BigNumberish) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\n\nexport class Reader {\n    readonly wordSize: number;\n    readonly allowLoose: boolean;\n\n    readonly _data: Uint8Array;\n    readonly _coerceFunc: CoerceFunc;\n\n    _offset: number;\n\n    constructor(data: BytesLike, wordSize?: number, coerceFunc?: CoerceFunc, allowLoose?: boolean) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n\n        this._offset = 0;\n    }\n\n    get data(): string { return hexlify(this._data); }\n    get consumed(): number { return this._offset; }\n\n    // The default Coerce function\n    static coerce(name: string, value: any): any {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) { value =  value.toNumber(); }\n        return value;\n    }\n\n    coerce(name: string, value: any): any {\n        if (this._coerceFunc) { return this._coerceFunc(name, value); }\n        return Reader.coerce(name, value);\n    }\n\n    _peekBytes(offset: number, length: number, loose?: boolean): Uint8Array {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            } else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength)\n    }\n\n    subReader(offset: number): Reader {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n\n    readBytes(length: number, loose?: boolean): Uint8Array {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n\n    readValue(): BigNumber {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"]},"metadata":{},"sourceType":"module"}