{"ast":null,"code":"\"use strict\";\n\nimport _inherits from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\n;\nvar _constructorGuard = {};\nvar ModifiersBytes = {\n  calldata: true,\n  memory: true,\n  storage: true\n};\nvar ModifiersNest = {\n  calldata: true,\n  memory: true\n};\n\nfunction checkModifier(type, name) {\n  if (type === \"bytes\" || type === \"string\") {\n    if (ModifiersBytes[name]) {\n      return true;\n    }\n  } else if (type === \"address\") {\n    if (name === \"payable\") {\n      return true;\n    }\n  } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n    if (ModifiersNest[name]) {\n      return true;\n    }\n  }\n\n  if (ModifiersBytes[name] || name === \"payable\") {\n    logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n  }\n\n  return false;\n} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\n\nfunction parseParamType(param, allowIndexed) {\n  var originalParam = param;\n\n  function throwError(i) {\n    logger.throwArgumentError(\"unexpected character at position \".concat(i), \"param\", param);\n  }\n\n  param = param.replace(/\\s/g, \" \");\n\n  function newNode(parent) {\n    var node = {\n      type: \"\",\n      name: \"\",\n      parent: parent,\n      state: {\n        allowType: true\n      }\n    };\n\n    if (allowIndexed) {\n      node.indexed = false;\n    }\n\n    return node;\n  }\n\n  var parent = {\n    type: \"\",\n    name: \"\",\n    state: {\n      allowType: true\n    }\n  };\n  var node = parent;\n\n  for (var i = 0; i < param.length; i++) {\n    var c = param[i];\n\n    switch (c) {\n      case \"(\":\n        if (node.state.allowType && node.type === \"\") {\n          node.type = \"tuple\";\n        } else if (!node.state.allowParams) {\n          throwError(i);\n        }\n\n        node.state.allowType = false;\n        node.type = verifyType(node.type);\n        node.components = [newNode(node)];\n        node = node.components[0];\n        break;\n\n      case \")\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var child = node;\n        node = node.parent;\n\n        if (!node) {\n          throwError(i);\n        }\n\n        delete child.parent;\n        node.state.allowParams = false;\n        node.state.allowName = true;\n        node.state.allowArray = true;\n        break;\n\n      case \",\":\n        delete node.state;\n\n        if (node.name === \"indexed\") {\n          if (!allowIndexed) {\n            throwError(i);\n          }\n\n          node.indexed = true;\n          node.name = \"\";\n        }\n\n        if (checkModifier(node.type, node.name)) {\n          node.name = \"\";\n        }\n\n        node.type = verifyType(node.type);\n        var sibling = newNode(node.parent); //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n\n        node.parent.components.push(sibling);\n        delete node.parent;\n        node = sibling;\n        break;\n      // Hit a space...\n\n      case \" \":\n        // If reading type, the type is done and may read a param or name\n        if (node.state.allowType) {\n          if (node.type !== \"\") {\n            node.type = verifyType(node.type);\n            delete node.state.allowType;\n            node.state.allowName = true;\n            node.state.allowParams = true;\n          }\n        } // If reading name, the name is done\n\n\n        if (node.state.allowName) {\n          if (node.name !== \"\") {\n            if (node.name === \"indexed\") {\n              if (!allowIndexed) {\n                throwError(i);\n              }\n\n              if (node.indexed) {\n                throwError(i);\n              }\n\n              node.indexed = true;\n              node.name = \"\";\n            } else if (checkModifier(node.type, node.name)) {\n              node.name = \"\";\n            } else {\n              node.state.allowName = false;\n            }\n          }\n        }\n\n        break;\n\n      case \"[\":\n        if (!node.state.allowArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.allowArray = false;\n        node.state.allowName = false;\n        node.state.readArray = true;\n        break;\n\n      case \"]\":\n        if (!node.state.readArray) {\n          throwError(i);\n        }\n\n        node.type += c;\n        node.state.readArray = false;\n        node.state.allowArray = true;\n        node.state.allowName = true;\n        break;\n\n      default:\n        if (node.state.allowType) {\n          node.type += c;\n          node.state.allowParams = true;\n          node.state.allowArray = true;\n        } else if (node.state.allowName) {\n          node.name += c;\n          delete node.state.allowArray;\n        } else if (node.state.readArray) {\n          node.type += c;\n        } else {\n          throwError(i);\n        }\n\n    }\n  }\n\n  if (node.parent) {\n    logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n  }\n\n  delete parent.state;\n\n  if (node.name === \"indexed\") {\n    if (!allowIndexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    if (node.indexed) {\n      throwError(originalParam.length - 7);\n    }\n\n    node.indexed = true;\n    node.name = \"\";\n  } else if (checkModifier(node.type, node.name)) {\n    node.name = \"\";\n  }\n\n  parent.type = verifyType(parent.type);\n  return parent;\n}\n\nfunction populate(object, params) {\n  for (var key in params) {\n    defineReadOnly(object, key, params[key]);\n  }\n}\n\nexport var FormatTypes = Object.freeze({\n  // Bare formatting, as is needed for computing a sighash of an event or function\n  sighash: \"sighash\",\n  // Human-Readable with Minimal spacing and without names (compact human-readable)\n  minimal: \"minimal\",\n  // Human-Readable with nice spacing, including all names\n  full: \"full\",\n  // JSON-format a la Solidity\n  json: \"json\"\n});\nvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport var ParamType = /*#__PURE__*/function () {\n  function ParamType(constructorGuard, params) {\n    _classCallCheck(this, ParamType);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new ParamType()\"\n      });\n    }\n\n    populate(this, params);\n    var match = this.type.match(paramTypeArray);\n\n    if (match) {\n      populate(this, {\n        arrayLength: parseInt(match[2] || \"-1\"),\n        arrayChildren: ParamType.fromObject({\n          type: match[1],\n          components: this.components\n        }),\n        baseType: \"array\"\n      });\n    } else {\n      populate(this, {\n        arrayLength: null,\n        arrayChildren: null,\n        baseType: this.components != null ? \"tuple\" : this.type\n      });\n    }\n\n    this._isParamType = true;\n    Object.freeze(this);\n  } // Format the parameter fragment\n  //   - sighash: \"(uint256,address)\"\n  //   - minimal: \"tuple(uint256,address) indexed\"\n  //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n\n\n  _createClass(ParamType, [{\n    key: \"format\",\n    value: function format(_format) {\n      if (!_format) {\n        _format = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format);\n      }\n\n      if (_format === FormatTypes.json) {\n        var _result = {\n          type: this.baseType === \"tuple\" ? \"tuple\" : this.type,\n          name: this.name || undefined\n        };\n\n        if (typeof this.indexed === \"boolean\") {\n          _result.indexed = this.indexed;\n        }\n\n        if (this.components) {\n          _result.components = this.components.map(function (comp) {\n            return JSON.parse(comp.format(_format));\n          });\n        }\n\n        return JSON.stringify(_result);\n      }\n\n      var result = \"\"; // Array\n\n      if (this.baseType === \"array\") {\n        result += this.arrayChildren.format(_format);\n        result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n      } else {\n        if (this.baseType === \"tuple\") {\n          if (_format !== FormatTypes.sighash) {\n            result += this.type;\n          }\n\n          result += \"(\" + this.components.map(function (comp) {\n            return comp.format(_format);\n          }).join(_format === FormatTypes.full ? \", \" : \",\") + \")\";\n        } else {\n          result += this.type;\n        }\n      }\n\n      if (_format !== FormatTypes.sighash) {\n        if (this.indexed === true) {\n          result += \" indexed\";\n        }\n\n        if (_format === FormatTypes.full && this.name) {\n          result += \" \" + this.name;\n        }\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value, allowIndexed) {\n      if (typeof value === \"string\") {\n        return ParamType.fromString(value, allowIndexed);\n      }\n\n      return ParamType.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ParamType.isParamType(value)) {\n        return value;\n      }\n\n      return new ParamType(_constructorGuard, {\n        name: value.name || null,\n        type: verifyType(value.type),\n        indexed: value.indexed == null ? null : !!value.indexed,\n        components: value.components ? value.components.map(ParamType.fromObject) : null\n      });\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value, allowIndexed) {\n      function ParamTypify(node) {\n        return ParamType.fromObject({\n          name: node.name,\n          type: node.type,\n          indexed: node.indexed,\n          components: node.components\n        });\n      }\n\n      return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n  }, {\n    key: \"isParamType\",\n    value: function isParamType(value) {\n      return !!(value != null && value._isParamType);\n    }\n  }]);\n\n  return ParamType;\n}();\n;\n\nfunction parseParams(value, allowIndex) {\n  return splitNesting(value).map(function (param) {\n    return ParamType.fromString(param, allowIndex);\n  });\n}\n\nexport var Fragment = /*#__PURE__*/function () {\n  function Fragment(constructorGuard, params) {\n    _classCallCheck(this, Fragment);\n\n    if (constructorGuard !== _constructorGuard) {\n      logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"new Fragment()\"\n      });\n    }\n\n    populate(this, params);\n    this._isFragment = true;\n    Object.freeze(this);\n  }\n\n  _createClass(Fragment, null, [{\n    key: \"from\",\n    value: function from(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n\n      if (typeof value === \"string\") {\n        return Fragment.fromString(value);\n      }\n\n      return Fragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (Fragment.isFragment(value)) {\n        return value;\n      }\n\n      switch (value.type) {\n        case \"function\":\n          return FunctionFragment.fromObject(value);\n\n        case \"event\":\n          return EventFragment.fromObject(value);\n\n        case \"constructor\":\n          return ConstructorFragment.fromObject(value);\n\n        case \"error\":\n          return ErrorFragment.fromObject(value);\n\n        case \"fallback\":\n        case \"receive\":\n          // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n          return null;\n      }\n\n      return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n      value = value.replace(/\\s/g, \" \");\n      value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n      value = value.trim();\n\n      if (value.split(\" \")[0] === \"event\") {\n        return EventFragment.fromString(value.substring(5).trim());\n      } else if (value.split(\" \")[0] === \"function\") {\n        return FunctionFragment.fromString(value.substring(8).trim());\n      } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n        return ConstructorFragment.fromString(value.trim());\n      } else if (value.split(\" \")[0] === \"error\") {\n        return ErrorFragment.fromString(value.substring(5).trim());\n      }\n\n      return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(value) {\n      return !!(value && value._isFragment);\n    }\n  }]);\n\n  return Fragment;\n}();\nexport var EventFragment = /*#__PURE__*/function (_Fragment) {\n  _inherits(EventFragment, _Fragment);\n\n  var _super = _createSuper(EventFragment);\n\n  function EventFragment() {\n    _classCallCheck(this, EventFragment);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(EventFragment, [{\n    key: \"format\",\n    value: function format(_format2) {\n      if (!_format2) {\n        _format2 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format2]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format2);\n      }\n\n      if (_format2 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"event\",\n          anonymous: this.anonymous,\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format2));\n          })\n        });\n      }\n\n      var result = \"\";\n\n      if (_format2 !== FormatTypes.sighash) {\n        result += \"event \";\n      }\n\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format2);\n      }).join(_format2 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (_format2 !== FormatTypes.sighash) {\n        if (this.anonymous) {\n          result += \"anonymous \";\n        }\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return EventFragment.fromString(value);\n      }\n\n      return EventFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (EventFragment.isEventFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"event\") {\n        logger.throwArgumentError(\"invalid event object\", \"value\", value);\n      }\n\n      var params = {\n        name: verifyIdentifier(value.name),\n        anonymous: value.anonymous,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        type: \"event\"\n      };\n      return new EventFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var match = value.match(regexParen);\n\n      if (!match) {\n        logger.throwArgumentError(\"invalid event string\", \"value\", value);\n      }\n\n      var anonymous = false;\n      match[3].split(\" \").forEach(function (modifier) {\n        switch (modifier.trim()) {\n          case \"anonymous\":\n            anonymous = true;\n            break;\n\n          case \"\":\n            break;\n\n          default:\n            logger.warn(\"unknown modifier: \" + modifier);\n        }\n      });\n      return EventFragment.fromObject({\n        name: match[1].trim(),\n        anonymous: anonymous,\n        inputs: parseParams(match[2], true),\n        type: \"event\"\n      });\n    }\n  }, {\n    key: \"isEventFragment\",\n    value: function isEventFragment(value) {\n      return value && value._isFragment && value.type === \"event\";\n    }\n  }]);\n\n  return EventFragment;\n}(Fragment);\n\nfunction parseGas(value, params) {\n  params.gas = null;\n  var comps = value.split(\"@\");\n\n  if (comps.length !== 1) {\n    if (comps.length > 2) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n    }\n\n    if (!comps[1].match(/^[0-9]+$/)) {\n      logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n    }\n\n    params.gas = BigNumber.from(comps[1]);\n    return comps[0];\n  }\n\n  return value;\n}\n\nfunction parseModifiers(value, params) {\n  params.constant = false;\n  params.payable = false;\n  params.stateMutability = \"nonpayable\";\n  value.split(\" \").forEach(function (modifier) {\n    switch (modifier.trim()) {\n      case \"constant\":\n        params.constant = true;\n        break;\n\n      case \"payable\":\n        params.payable = true;\n        params.stateMutability = \"payable\";\n        break;\n\n      case \"nonpayable\":\n        params.payable = false;\n        params.stateMutability = \"nonpayable\";\n        break;\n\n      case \"pure\":\n        params.constant = true;\n        params.stateMutability = \"pure\";\n        break;\n\n      case \"view\":\n        params.constant = true;\n        params.stateMutability = \"view\";\n        break;\n\n      case \"external\":\n      case \"public\":\n      case \"\":\n        break;\n\n      default:\n        console.log(\"unknown modifier: \" + modifier);\n    }\n  });\n}\n\nfunction verifyState(value) {\n  var result = {\n    constant: false,\n    payable: true,\n    stateMutability: \"payable\"\n  };\n\n  if (value.stateMutability != null) {\n    result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property\n\n    result.constant = result.stateMutability === \"view\" || result.stateMutability === \"pure\";\n\n    if (value.constant != null) {\n      if (!!value.constant !== result.constant) {\n        logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    } // Set (and check things are consistent) the payable property\n\n\n    result.payable = result.stateMutability === \"payable\";\n\n    if (value.payable != null) {\n      if (!!value.payable !== result.payable) {\n        logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n      }\n    }\n  } else if (value.payable != null) {\n    result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume\n\n    if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n      logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    result.constant = !!value.constant;\n\n    if (result.constant) {\n      result.stateMutability = \"view\";\n    } else {\n      result.stateMutability = result.payable ? \"payable\" : \"nonpayable\";\n    }\n\n    if (result.payable && result.constant) {\n      logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n    }\n  } else if (value.constant != null) {\n    result.constant = !!value.constant;\n    result.payable = !result.constant;\n    result.stateMutability = result.constant ? \"view\" : \"payable\";\n  } else if (value.type !== \"constructor\") {\n    logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n  }\n\n  return result;\n}\n\nexport var ConstructorFragment = /*#__PURE__*/function (_Fragment2) {\n  _inherits(ConstructorFragment, _Fragment2);\n\n  var _super2 = _createSuper(ConstructorFragment);\n\n  function ConstructorFragment() {\n    _classCallCheck(this, ConstructorFragment);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ConstructorFragment, [{\n    key: \"format\",\n    value: function format(_format3) {\n      if (!_format3) {\n        _format3 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format3]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format3);\n      }\n\n      if (_format3 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"constructor\",\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payable: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format3));\n          })\n        });\n      }\n\n      if (_format3 === FormatTypes.sighash) {\n        logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"format(sighash)\"\n        });\n      }\n\n      var result = \"constructor(\" + this.inputs.map(function (input) {\n        return input.format(_format3);\n      }).join(_format3 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n        result += this.stateMutability + \" \";\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ConstructorFragment.fromString(value);\n      }\n\n      return ConstructorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ConstructorFragment.isConstructorFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n      }\n\n      var state = verifyState(value);\n\n      if (state.constant) {\n        logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n      }\n\n      var params = {\n        name: null,\n        type: value.type,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new ConstructorFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"constructor\"\n      };\n      value = parseGas(value, params);\n      var parens = value.match(regexParen);\n\n      if (!parens || parens[1].trim() !== \"constructor\") {\n        logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n      }\n\n      params.inputs = parseParams(parens[2].trim(), false);\n      parseModifiers(parens[3].trim(), params);\n      return ConstructorFragment.fromObject(params);\n    }\n  }, {\n    key: \"isConstructorFragment\",\n    value: function isConstructorFragment(value) {\n      return value && value._isFragment && value.type === \"constructor\";\n    }\n  }]);\n\n  return ConstructorFragment;\n}(Fragment);\nexport var FunctionFragment = /*#__PURE__*/function (_ConstructorFragment) {\n  _inherits(FunctionFragment, _ConstructorFragment);\n\n  var _super3 = _createSuper(FunctionFragment);\n\n  function FunctionFragment() {\n    _classCallCheck(this, FunctionFragment);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(FunctionFragment, [{\n    key: \"format\",\n    value: function format(_format4) {\n      if (!_format4) {\n        _format4 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format4]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format4);\n      }\n\n      if (_format4 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"function\",\n          name: this.name,\n          constant: this.constant,\n          stateMutability: this.stateMutability !== \"nonpayable\" ? this.stateMutability : undefined,\n          payable: this.payable,\n          gas: this.gas ? this.gas.toNumber() : undefined,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format4));\n          }),\n          outputs: this.outputs.map(function (output) {\n            return JSON.parse(output.format(_format4));\n          })\n        });\n      }\n\n      var result = \"\";\n\n      if (_format4 !== FormatTypes.sighash) {\n        result += \"function \";\n      }\n\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format4);\n      }).join(_format4 === FormatTypes.full ? \", \" : \",\") + \") \";\n\n      if (_format4 !== FormatTypes.sighash) {\n        if (this.stateMutability) {\n          if (this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n          }\n        } else if (this.constant) {\n          result += \"view \";\n        }\n\n        if (this.outputs && this.outputs.length) {\n          result += \"returns (\" + this.outputs.map(function (output) {\n            return output.format(_format4);\n          }).join(\", \") + \") \";\n        }\n\n        if (this.gas != null) {\n          result += \"@\" + this.gas.toString() + \" \";\n        }\n      }\n\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return FunctionFragment.fromString(value);\n      }\n\n      return FunctionFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (FunctionFragment.isFunctionFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"function\") {\n        logger.throwArgumentError(\"invalid function object\", \"value\", value);\n      }\n\n      var state = verifyState(value);\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        constant: state.constant,\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],\n        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],\n        payable: state.payable,\n        stateMutability: state.stateMutability,\n        gas: value.gas ? BigNumber.from(value.gas) : null\n      };\n      return new FunctionFragment(_constructorGuard, params);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"function\"\n      };\n      value = parseGas(value, params);\n      var comps = value.split(\" returns \");\n\n      if (comps.length > 2) {\n        logger.throwArgumentError(\"invalid function string\", \"value\", value);\n      }\n\n      var parens = comps[0].match(regexParen);\n\n      if (!parens) {\n        logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n      }\n\n      params.name = parens[1].trim();\n\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n\n      params.inputs = parseParams(parens[2], false);\n      parseModifiers(parens[3].trim(), params); // We have outputs\n\n      if (comps.length > 1) {\n        var returns = comps[1].match(regexParen);\n\n        if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n          logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n        }\n\n        params.outputs = parseParams(returns[2], false);\n      } else {\n        params.outputs = [];\n      }\n\n      return FunctionFragment.fromObject(params);\n    }\n  }, {\n    key: \"isFunctionFragment\",\n    value: function isFunctionFragment(value) {\n      return value && value._isFragment && value.type === \"function\";\n    }\n  }]);\n\n  return FunctionFragment;\n}(ConstructorFragment); //export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment) {\n  var sig = fragment.format();\n\n  if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n    logger.throwArgumentError(\"cannot specify user defined \".concat(sig, \" error\"), \"fragment\", fragment);\n  }\n\n  return fragment;\n}\n\nexport var ErrorFragment = /*#__PURE__*/function (_Fragment3) {\n  _inherits(ErrorFragment, _Fragment3);\n\n  var _super4 = _createSuper(ErrorFragment);\n\n  function ErrorFragment() {\n    _classCallCheck(this, ErrorFragment);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(ErrorFragment, [{\n    key: \"format\",\n    value: function format(_format5) {\n      if (!_format5) {\n        _format5 = FormatTypes.sighash;\n      }\n\n      if (!FormatTypes[_format5]) {\n        logger.throwArgumentError(\"invalid format type\", \"format\", _format5);\n      }\n\n      if (_format5 === FormatTypes.json) {\n        return JSON.stringify({\n          type: \"error\",\n          name: this.name,\n          inputs: this.inputs.map(function (input) {\n            return JSON.parse(input.format(_format5));\n          })\n        });\n      }\n\n      var result = \"\";\n\n      if (_format5 !== FormatTypes.sighash) {\n        result += \"error \";\n      }\n\n      result += this.name + \"(\" + this.inputs.map(function (input) {\n        return input.format(_format5);\n      }).join(_format5 === FormatTypes.full ? \", \" : \",\") + \") \";\n      return result.trim();\n    }\n  }], [{\n    key: \"from\",\n    value: function from(value) {\n      if (typeof value === \"string\") {\n        return ErrorFragment.fromString(value);\n      }\n\n      return ErrorFragment.fromObject(value);\n    }\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(value) {\n      if (ErrorFragment.isErrorFragment(value)) {\n        return value;\n      }\n\n      if (value.type !== \"error\") {\n        logger.throwArgumentError(\"invalid error object\", \"value\", value);\n      }\n\n      var params = {\n        type: value.type,\n        name: verifyIdentifier(value.name),\n        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []\n      };\n      return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(value) {\n      var params = {\n        type: \"error\"\n      };\n      var parens = value.match(regexParen);\n\n      if (!parens) {\n        logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n      }\n\n      params.name = parens[1].trim();\n\n      if (params.name) {\n        verifyIdentifier(params.name);\n      }\n\n      params.inputs = parseParams(parens[2], false);\n      return checkForbidden(ErrorFragment.fromObject(params));\n    }\n  }, {\n    key: \"isErrorFragment\",\n    value: function isErrorFragment(value) {\n      return value && value._isFragment && value.type === \"error\";\n    }\n  }]);\n\n  return ErrorFragment;\n}(Fragment);\n\nfunction verifyType(type) {\n  // These need to be transformed to their full description\n  if (type.match(/^uint($|[^1-9])/)) {\n    type = \"uint256\" + type.substring(4);\n  } else if (type.match(/^int($|[^1-9])/)) {\n    type = \"int256\" + type.substring(3);\n  } // @TODO: more verification\n\n\n  return type;\n} // See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\n\n\nvar regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\n\nfunction verifyIdentifier(value) {\n  if (!value || !value.match(regexIdentifier)) {\n    logger.throwArgumentError(\"invalid identifier \\\"\".concat(value, \"\\\"\"), \"value\", value);\n  }\n\n  return value;\n}\n\nvar regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value) {\n  value = value.trim();\n  var result = [];\n  var accum = \"\";\n  var depth = 0;\n\n  for (var offset = 0; offset < value.length; offset++) {\n    var c = value[offset];\n\n    if (c === \",\" && depth === 0) {\n      result.push(accum);\n      accum = \"\";\n    } else {\n      accum += c;\n\n      if (c === \"(\") {\n        depth++;\n      } else if (c === \")\") {\n        depth--;\n\n        if (depth === -1) {\n          logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n        }\n      }\n    }\n  }\n\n  if (accum) {\n    result.push(accum);\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@ethersproject/abi/src.ts/fragments.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport interface JsonFragmentType {\n    readonly name?: string;\n    readonly indexed?: boolean;\n    readonly type?: string;\n    readonly internalType?: any; // @TODO: in v6 reduce type\n    readonly components?: ReadonlyArray<JsonFragmentType>;\n}\n\nexport interface JsonFragment {\n    readonly name?: string;\n    readonly type?: string;\n\n    readonly anonymous?: boolean;\n\n    readonly payable?: boolean;\n    readonly constant?: boolean;\n    readonly stateMutability?: string;\n\n    readonly inputs?: ReadonlyArray<JsonFragmentType>;\n    readonly outputs?: ReadonlyArray<JsonFragmentType>;\n\n    readonly gas?: string;\n};\n\nconst _constructorGuard = { };\n\n// AST Node parser state\ntype ParseState = {\n    allowArray?: boolean,\n    allowName?: boolean,\n    allowParams?: boolean,\n    allowType?: boolean,\n    readArray?: boolean,\n};\n\n// AST Node\ntype ParseNode = {\n    parent?: any,\n    type?: string,\n    name?: string,\n    state?: ParseState,\n    indexed?: boolean,\n    components?: Array<ParseNode>\n};\n\nlet ModifiersBytes: { [ name: string ]: boolean } = { calldata: true, memory: true, storage: true };\nlet ModifiersNest: { [ name: string ]: boolean } = { calldata: true, memory: true };\nfunction checkModifier(type: string, name: string): boolean {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) { return true; }\n    } else if (type === \"address\") {\n        if (name === \"payable\") { return true; }\n    } else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) { return true; }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param: string, allowIndexed: boolean): ParseNode {\n\n    let originalParam = param;\n    function throwError(i: number) {\n        logger.throwArgumentError(`unexpected character at position ${ i }`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n\n    function newNode(parent: ParseNode): ParseNode {\n        let node: ParseNode = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) { node.indexed = false; }\n        return node\n    }\n\n    let parent: ParseNode = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                } else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [ newNode(node) ];\n                node = node.components[0];\n                break;\n\n            case \")\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let child = node;\n                node = node.parent;\n                if (!node) { throwError(i); }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n\n            case \",\":\n                delete node.state;\n\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) { throwError(i); }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n\n                if (checkModifier(node.type, node.name)) { node.name = \"\"; }\n\n                node.type = verifyType(node.type);\n\n                let sibling: ParseNode = newNode(node.parent);\n                 //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n\n            // Hit a space...\n            case \" \":\n\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) { throwError(i); }\n                            if (node.indexed) { throwError(i); }\n                            node.indexed = true;\n                            node.name = \"\";\n                        } else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        } else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n\n                break;\n\n            case \"[\":\n                if (!node.state.allowArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n\n            case \"]\":\n                if (!node.state.readArray) { throwError(i); }\n\n                node.type += c;\n\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                } else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                } else if (node.state.readArray) {\n                    node.type += c;\n                } else {\n                    throwError(i);\n               }\n        }\n    }\n\n    if (node.parent) { logger.throwArgumentError(\"unexpected eof\", \"param\", param); }\n\n    delete parent.state;\n\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) { throwError(originalParam.length - 7); }\n        if (node.indexed) { throwError(originalParam.length - 7); }\n        node.indexed = true;\n        node.name = \"\";\n    } else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n\n    parent.type = verifyType(parent.type);\n\n    return parent;\n}\n\nfunction populate(object: any, params: any) {\n    for (let key in params) { defineReadOnly(object, key, params[key]); }\n}\n\nexport const FormatTypes: { [ name: string ]: string } = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n\n    // JSON-format a la Solidity\n    json: \"json\"\n});\n\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\nexport class ParamType {\n\n    // The local name of the parameter (of null if unbound)\n    readonly name: string;\n\n    // The fully qualified type (e.g. \"address\", \"tuple(address)\", \"uint256[3][]\"\n    readonly type: string;\n\n    // The base type (e.g. \"address\", \"tuple\", \"array\")\n    readonly baseType: string;\n\n    // Indexable Paramters ONLY (otherwise null)\n    readonly indexed: boolean;\n\n    // Tuples ONLY: (otherwise null)\n    //  - sub-components\n    readonly components: Array<ParamType>;\n\n    // Arrays ONLY: (otherwise null)\n    //  - length of the array (-1 for dynamic length)\n    //  - child type\n    readonly arrayLength: number;\n    readonly arrayChildren: ParamType;\n\n    readonly _isParamType: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) { logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new ParamType()\"\n        }); }\n        populate(this, params);\n\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        } else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\": this.type)\n            });\n        }\n\n        this._isParamType = true;\n\n        Object.freeze(this);\n    }\n\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            let result: any = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\": this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof(this.indexed) === \"boolean\") { result.indexed = this.indexed; }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n\n        let result = \"\";\n\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\": String(this.arrayLength)) + \"]\";\n        } else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map(\n                    (comp) => comp.format(format)\n                ).join((format === FormatTypes.full) ? \", \": \",\") + \")\";\n            } else {\n                result += this.type;\n            }\n        }\n\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) { result += \" indexed\"; }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n\n        return result;\n    }\n\n    static from(value: string | JsonFragmentType | ParamType, allowIndexed?: boolean): ParamType {\n        if (typeof(value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragmentType | ParamType): ParamType {\n        if (ParamType.isParamType(value)) { return value; }\n\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null: !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject): null)\n        });\n    }\n\n    static fromString(value: string, allowIndexed?: boolean): ParamType {\n        function ParamTypify(node: ParseNode): ParamType {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n\n    static isParamType(value: any): value is ParamType {\n        return !!(value != null && value._isParamType);\n    }\n};\n\nfunction parseParams(value: string, allowIndex: boolean): Array<ParamType> {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\n\ntype TypeCheck<T> = { -readonly [ K in keyof T ]: T[K] };\n\ninterface _Fragment {\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: ReadonlyArray<ParamType>;\n}\n\nexport abstract class Fragment {\n\n    readonly type: string;\n    readonly name: string;\n    readonly inputs: Array<ParamType>;\n\n    readonly _isFragment: boolean;\n\n    constructor(constructorGuard: any, params: any) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n\n        this._isFragment = true;\n\n        Object.freeze(this);\n    }\n\n    abstract format(format?: string): string;\n\n    static from(value: Fragment | JsonFragment | string): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        if (typeof(value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n\n        return Fragment.fromObject(value);\n    }\n\n    static fromObject(value: Fragment | JsonFragment): Fragment {\n        if (Fragment.isFragment(value)) { return value; }\n\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n\n    static fromString(value: string): Fragment {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n\n        if (value.split(\" \")[0] === \"event\") {\n           return EventFragment.fromString(value.substring(5).trim());\n        } else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        } else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        } else if (value.split(\" \")[0] === \"error\") {\n           return ErrorFragment.fromString(value.substring(5).trim());\n        }\n\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n\n    static isFragment(value: any): value is Fragment {\n        return !!(value && value._isFragment);\n    }\n}\n\ninterface _EventFragment extends _Fragment {\n    readonly anonymous: boolean;\n}\n\nexport class EventFragment extends Fragment {\n    readonly anonymous: boolean;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: EventFragment | JsonFragment | string): EventFragment {\n        if (typeof(value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n\n    static fromObject(value: JsonFragment | EventFragment): EventFragment {\n        if (EventFragment.isEventFragment(value)) { return value; }\n\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_EventFragment> = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n\n        return new EventFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): EventFragment {\n\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch(modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n\n    static isEventFragment(value: any): value is EventFragment {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\n\nfunction parseGas(value: string, params: any): string {\n    params.gas = null;\n\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n\n    return value;\n}\n\nfunction parseModifiers(value: string, params: any): void {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\n\ntype StateInputValue = {\n    constant?: boolean;\n    payable?: boolean;\n    stateMutability?: string;\n    type?: string;\n};\n\ntype StateOutputValue = {\n    constant: boolean;\n    payable: boolean;\n    stateMutability: string;\n};\n\nfunction verifyState(value: StateInputValue): StateOutputValue {\n    let result: any = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n\n    } else if (value.payable != null) {\n        result.payable = !!value.payable;\n\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n\n        result.constant = !!value.constant;\n\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        } else {\n            result.stateMutability = (result.payable ? \"payable\": \"nonpayable\");\n        }\n\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n\n    } else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\": \"payable\");\n\n    } else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n\n    return result;\n}\n\ninterface _ConstructorFragment extends _Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n}\n\nexport class ConstructorFragment extends Fragment {\n    stateMutability: string;\n    payable: boolean;\n    gas?: BigNumber;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n\n        let result = \"constructor(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n\n        return result.trim();\n    }\n\n    static from(value: ConstructorFragment | JsonFragment | string): ConstructorFragment {\n        if (typeof(value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ConstructorFragment | JsonFragment): ConstructorFragment {\n        if (ConstructorFragment.isConstructorFragment(value)) { return value; }\n\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n\n        const params: TypeCheck<_ConstructorFragment> = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): ConstructorFragment {\n        let params: any = { type: \"constructor\" };\n\n        value = parseGas(value, params);\n\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n\n        params.inputs = parseParams(parens[2].trim(), false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        return ConstructorFragment.fromObject(params);\n    }\n\n    static isConstructorFragment(value: any): value is ConstructorFragment {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\n\ninterface _FunctionFragment extends _ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n}\n\nexport class FunctionFragment extends ConstructorFragment {\n    constant: boolean;\n    outputs?: Array<ParamType>;\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability: undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber(): undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            } else if (this.constant) {\n                result += \"view \";\n            }\n\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map(\n                    (output) => output.format(format)\n                ).join(\", \") + \") \";\n            }\n\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n\n        return result.trim();\n    }\n\n    static from(value: FunctionFragment | JsonFragment | string): FunctionFragment {\n        if (typeof(value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n\n    static fromObject(value: FunctionFragment | JsonFragment): FunctionFragment {\n        if (FunctionFragment.isFunctionFragment(value)) { return value; }\n\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n\n        let state = verifyState(value);\n\n        const params: TypeCheck<_FunctionFragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject): [ ]),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas): null)\n        };\n\n        return new FunctionFragment(_constructorGuard, params);\n    }\n\n    static fromString(value: string): FunctionFragment {\n        let params: any = { type: \"function\" };\n        value = parseGas(value, params);\n\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        parseModifiers(parens[3].trim(), params);\n\n        // We have outputs\n        if (comps.length > 1) {\n           let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        } else {\n            params.outputs = [ ];\n        }\n\n        return FunctionFragment.fromObject(params);\n    }\n\n    static isFunctionFragment(value: any): value is FunctionFragment {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n\n//export class StructFragment extends Fragment {\n//}\n\nfunction checkForbidden(fragment: ErrorFragment): ErrorFragment {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${ sig } error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\n\nexport class ErrorFragment extends Fragment {\n\n    format(format?: string): string {\n        if (!format) { format = FormatTypes.sighash; }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n\n        let result = \"\";\n\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n\n        result += this.name + \"(\" + this.inputs.map(\n            (input) => input.format(format)\n        ).join((format === FormatTypes.full) ? \", \": \",\") + \") \";\n\n        return result.trim();\n    }\n\n    static from(value: ErrorFragment | JsonFragment | string): ErrorFragment {\n        if (typeof(value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n\n    static fromObject(value: ErrorFragment | JsonFragment): ErrorFragment {\n        if (ErrorFragment.isErrorFragment(value)) { return value; }\n\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n\n        const params: TypeCheck<_Fragment> = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject): [])\n        };\n\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n\n    static fromString(value: string): ErrorFragment {\n        let params: any = { type: \"error\" };\n\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n\n        params.name = parens[1].trim();\n        if (params.name) { verifyIdentifier(params.name); }\n\n        params.inputs = parseParams(parens[2], false);\n\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n\n    static isErrorFragment(value: any): value is ErrorFragment {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\n\nfunction verifyType(type: string): string {\n\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    } else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n\n    // @TODO: more verification\n\n    return type;\n}\n\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value: string): string {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${ value }\"`, \"value\", value);\n    }\n    return value;\n}\n\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\n\nfunction splitNesting(value: string): Array<any> {\n    value = value.trim();\n\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        } else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            } else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) { result.push(accum); }\n\n    return result;\n}\n\n"]},"metadata":{},"sourceType":"module"}