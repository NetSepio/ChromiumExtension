{"ast":null,"code":"import _classCallCheck from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _regeneratorRuntime from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@babel/runtime/regenerator/index.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { id } from \"./id\";\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar NegativeOne = BigNumber.from(-1);\nvar Zero = BigNumber.from(0);\nvar One = BigNumber.from(1);\nvar MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value) {\n  var bytes = arrayify(value);\n  var padOffset = bytes.length % 32;\n\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n\n  return hexlify(bytes);\n}\n\nvar hexTrue = hexZeroPad(One.toHexString(), 32);\nvar hexFalse = hexZeroPad(Zero.toHexString(), 32);\nvar domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nvar domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\n\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(\"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    }\n\n    return value;\n  };\n}\n\nvar domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function chainId(value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n  },\n  verifyingContract: function verifyingContract(value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function salt(value) {\n    try {\n      var bytes = arrayify(value);\n\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n\n      return hexlify(bytes);\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n  }\n};\n\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    var match = type.match(/^(u?)int(\\d*)$/);\n\n    if (match) {\n      var signed = match[1] === \"\";\n      var width = parseInt(match[2] || \"256\");\n\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n\n      var boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      var boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        var v = BigNumber.from(value);\n\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(\"value out-of-bounds for \".concat(type), \"value\", value);\n        }\n\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  } // bytesXX\n\n  {\n    var _match = type.match(/^bytes(\\d+)$/);\n\n    if (_match) {\n      var _width = parseInt(_match[1]);\n\n      if (_width === 0 || _width > 32 || _match[1] !== String(_width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n\n      return function (value) {\n        var bytes = arrayify(value);\n\n        if (bytes.length !== _width) {\n          logger.throwArgumentError(\"invalid length for \".concat(type), \"value\", value);\n        }\n\n        return hexPadRight(value);\n      };\n    }\n  }\n\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n\n  return null;\n}\n\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(function (_ref) {\n    var name = _ref.name,\n        type = _ref.type;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\n\nexport var TypedDataEncoder = /*#__PURE__*/function () {\n  function TypedDataEncoder(types) {\n    _classCallCheck(this, TypedDataEncoder);\n\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {}); // Link struct types to their direct child structs\n\n    var links = {}; // Link structs to structs which contain them as a child\n\n    var parents = {}; // Link all subtypes within a given struct\n\n    var subtypes = {};\n    Object.keys(types).forEach(function (type) {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n\n    var _loop = function _loop(name) {\n      var uniqueNames = {};\n      types[name].forEach(function (field) {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(\"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n        }\n\n        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)\n\n        var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n\n        if (baseType === name) {\n          logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n        } // Is this a base encoding type?\n\n\n        var encoder = getBaseEncoder(baseType);\n\n        if (encoder) {\n          return;\n        }\n\n        if (!parents[baseType]) {\n          logger.throwArgumentError(\"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n        } // Add linkage\n\n\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    };\n\n    for (var name in types) {\n      _loop(name);\n    } // Deduce the primary type\n\n\n    var primaryTypes = Object.keys(parents).filter(function (n) {\n      return parents[n].length === 0;\n    });\n\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(\"ambiguous primary types or unused types: \".concat(primaryTypes.map(function (t) {\n        return JSON.stringify(t);\n      }).join(\", \")), \"types\", types);\n    }\n\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]); // Check for circular type references\n\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      }\n\n      found[type] = true;\n      Object.keys(links[type]).forEach(function (child) {\n        if (!parents[child]) {\n          return;\n        } // Recursively check children\n\n\n        checkCircular(child, found); // Mark all ancestors as having this decendant\n\n        Object.keys(found).forEach(function (subtype) {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n\n    checkCircular(this.primaryType, {}); // Compute each fully describe type\n\n    for (var _name in subtypes) {\n      var st = Object.keys(subtypes[_name]);\n      st.sort();\n      this._types[_name] = encodeType(_name, types[_name]) + st.map(function (t) {\n        return encodeType(t, types[t]);\n      }).join(\"\");\n    }\n  }\n\n  _createClass(TypedDataEncoder, [{\n    key: \"getEncoder\",\n    value: function getEncoder(type) {\n      var encoder = this._encoderCache[type];\n\n      if (!encoder) {\n        encoder = this._encoderCache[type] = this._getEncoder(type);\n      }\n\n      return encoder;\n    }\n  }, {\n    key: \"_getEncoder\",\n    value: function _getEncoder(type) {\n      var _this = this;\n\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n\n        if (encoder) {\n          return encoder;\n        }\n      } // Array\n\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n      if (match) {\n        var subtype = match[1];\n        var subEncoder = this.getEncoder(subtype);\n        var length = parseInt(match[3]);\n        return function (value) {\n          if (length >= 0 && value.length !== length) {\n            logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n          }\n\n          var result = value.map(subEncoder);\n\n          if (_this._types[subtype]) {\n            result = result.map(keccak256);\n          }\n\n          return keccak256(hexConcat(result));\n        };\n      } // Struct\n\n\n      var fields = this.types[type];\n\n      if (fields) {\n        var encodedType = id(this._types[type]);\n        return function (value) {\n          var values = fields.map(function (_ref2) {\n            var name = _ref2.name,\n                type = _ref2.type;\n\n            var result = _this.getEncoder(type)(value[name]);\n\n            if (_this._types[type]) {\n              return keccak256(result);\n            }\n\n            return result;\n          });\n          values.unshift(encodedType);\n          return hexConcat(values);\n        };\n      }\n\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType(name) {\n      var result = this._types[name];\n\n      if (!result) {\n        logger.throwArgumentError(\"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encodeData\",\n    value: function encodeData(type, value) {\n      return this.getEncoder(type)(value);\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, value) {\n      return keccak256(this.encodeData(name, value));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      return this.encodeData(this.primaryType, value);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(value) {\n      return this.hashStruct(this.primaryType, value);\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(type, value, callback) {\n      var _this2 = this;\n\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n\n        if (encoder) {\n          return callback(type, value);\n        }\n      } // Array\n\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n      if (match) {\n        var subtype = match[1];\n        var length = parseInt(match[3]);\n\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n\n        return value.map(function (v) {\n          return _this2._visit(subtype, v, callback);\n        });\n      } // Struct\n\n\n      var fields = this.types[type];\n\n      if (fields) {\n        return fields.reduce(function (accum, _ref3) {\n          var name = _ref3.name,\n              type = _ref3.type;\n          accum[name] = _this2._visit(type, value[name], callback);\n          return accum;\n        }, {});\n      }\n\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"visit\",\n    value: function visit(value, callback) {\n      return this._visit(this.primaryType, value, callback);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(types) {\n      return new TypedDataEncoder(types);\n    }\n  }, {\n    key: \"getPrimaryType\",\n    value: function getPrimaryType(types) {\n      return TypedDataEncoder.from(types).primaryType;\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, types, value) {\n      return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n  }, {\n    key: \"hashDomain\",\n    value: function hashDomain(domain) {\n      var domainFields = [];\n\n      for (var name in domain) {\n        var type = domainFieldTypes[name];\n\n        if (!type) {\n          logger.throwArgumentError(\"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n        }\n\n        domainFields.push({\n          name: name,\n          type: type\n        });\n      }\n\n      domainFields.sort(function (a, b) {\n        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n      });\n      return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n        EIP712Domain: domainFields\n      }, domain);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(domain, types, value) {\n      return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(domain, types, value) {\n      return keccak256(TypedDataEncoder.encode(domain, types, value));\n    } // Replaces all address types with ENS names with their looked up address\n\n  }, {\n    key: \"resolveNames\",\n    value: function resolveNames(domain, types, value, resolveName) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var ensCache, encoder, name;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Make a copy to isolate it from the object passed in\n                domain = shallowCopy(domain); // Look up all ENS names\n\n                ensCache = {}; // Do we need to look up the domain's verifyingContract?\n\n                if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                  ensCache[domain.verifyingContract] = \"0x\";\n                } // We are going to use the encoder to visit all the base values\n\n\n                encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n\n                encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                  }\n\n                  return value;\n                }); // Lookup each name\n\n                _context.t0 = _regeneratorRuntime.keys(ensCache);\n\n              case 6:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 13;\n                  break;\n                }\n\n                name = _context.t1.value;\n                _context.next = 10;\n                return resolveName(name);\n\n              case 10:\n                ensCache[name] = _context.sent;\n                _context.next = 6;\n                break;\n\n              case 13:\n                // Replace the domain verifyingContract if needed\n                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                  domain.verifyingContract = ensCache[domain.verifyingContract];\n                } // Replace all ENS names with their address\n\n\n                value = encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                  }\n\n                  return value;\n                });\n                return _context.abrupt(\"return\", {\n                  domain: domain,\n                  value: value\n                });\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getPayload\",\n    value: function getPayload(domain, types, value) {\n      // Validate the domain fields\n      TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type\n\n      var domainValues = {};\n      var domainTypes = [];\n      domainFieldNames.forEach(function (name) {\n        var value = domain[name];\n\n        if (value == null) {\n          return;\n        }\n\n        domainValues[name] = domainChecks[name](value);\n        domainTypes.push({\n          name: name,\n          type: domainFieldTypes[name]\n        });\n      });\n      var encoder = TypedDataEncoder.from(types);\n      var typesWithDomain = shallowCopy(types);\n\n      if (typesWithDomain.EIP712Domain) {\n        logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n      } else {\n        typesWithDomain.EIP712Domain = domainTypes;\n      } // Validate the data structures and types\n\n\n      encoder.encode(value);\n      return {\n        types: typesWithDomain,\n        domain: domainValues,\n        primaryType: encoder.primaryType,\n        message: encoder.visit(value, function (type, value) {\n          // bytes\n          if (type.match(/^bytes(\\d*)/)) {\n            return hexlify(arrayify(value));\n          } // uint or int\n\n\n          if (type.match(/^u?int/)) {\n            return BigNumber.from(value).toString();\n          }\n\n          switch (type) {\n            case \"address\":\n              return value.toLowerCase();\n\n            case \"bool\":\n              return !!value;\n\n            case \"string\":\n              if (typeof value !== \"string\") {\n                logger.throwArgumentError(\"invalid string\", \"value\", value);\n              }\n\n              return value;\n          }\n\n          return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n        })\n      };\n    }\n  }]);\n\n  return TypedDataEncoder;\n}();","map":{"version":3,"sources":["/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/net-sapio/node_modules/@ethersproject/hash/src.ts/typed-data.ts"],"names":[],"mappings":"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","sourcesContent":["import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}