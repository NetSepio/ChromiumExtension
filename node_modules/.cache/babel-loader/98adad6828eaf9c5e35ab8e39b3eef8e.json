{"ast":null,"code":"\"use strict\";\n\nimport _classCallCheck from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { wordlists } from \"@ethersproject/wordlists\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nvar N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"); // \"Bitcoin seed\"\n\nvar MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\nvar HardenedBit = 0x80000000; // Returns a byte with the MSB bits set\n\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n} // Returns a byte with the LSB bits set\n\n\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\n\nfunction bytes32(value) {\n  return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data) {\n  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\n\nfunction getWordlist(wordlist) {\n  if (wordlist == null) {\n    return wordlists[\"en\"];\n  }\n\n  if (typeof wordlist === \"string\") {\n    var words = wordlists[wordlist];\n\n    if (words == null) {\n      logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n    }\n\n    return words;\n  }\n\n  return wordlist;\n}\n\nvar _constructorGuard = {};\nexport var defaultPath = \"m/44'/60'/0'/0/0\";\n;\nexport var HDNode = /*#__PURE__*/function () {\n  /**\n   *  This constructor should not be called directly.\n   *\n   *  Please use:\n   *   - fromMnemonic\n   *   - fromSeed\n   */\n  function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n    _classCallCheck(this, HDNode);\n\n    logger.checkNew(this instanceof HDNode ? this.constructor : void 0, HDNode);\n    /* istanbul ignore if */\n\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error(\"HDNode constructor cannot be called directly\");\n    }\n\n    if (privateKey) {\n      var signingKey = new SigningKey(privateKey);\n      defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n      defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n    } else {\n      defineReadOnly(this, \"privateKey\", null);\n      defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n    }\n\n    defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n    defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n    defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n    defineReadOnly(this, \"chainCode\", chainCode);\n    defineReadOnly(this, \"index\", index);\n    defineReadOnly(this, \"depth\", depth);\n\n    if (mnemonicOrPath == null) {\n      // From a source that does not preserve the path (e.g. extended keys)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", null);\n    } else if (typeof mnemonicOrPath === \"string\") {\n      // From a source that does not preserve the mnemonic (e.g. neutered)\n      defineReadOnly(this, \"mnemonic\", null);\n      defineReadOnly(this, \"path\", mnemonicOrPath);\n    } else {\n      // From a fully qualified source\n      defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n      defineReadOnly(this, \"path\", mnemonicOrPath.path);\n    }\n  }\n\n  _createClass(HDNode, [{\n    key: \"extendedKey\",\n    get: function get() {\n      // We only support the mainnet values for now, but if anyone needs\n      // testnet values, let me know. I believe current sentiment is that\n      // we should always use mainnet, and use BIP-44 to derive the network\n      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n      //   - Testnet: public=0x043587CF, private=0x04358394\n      if (this.depth >= 256) {\n        throw new Error(\"Depth too large!\");\n      }\n\n      return base58check(concat([this.privateKey != null ? \"0x0488ADE4\" : \"0x0488B21E\", hexlify(this.depth), this.parentFingerprint, hexZeroPad(hexlify(this.index), 4), this.chainCode, this.privateKey != null ? concat([\"0x00\", this.privateKey]) : this.publicKey]));\n    }\n  }, {\n    key: \"neuter\",\n    value: function neuter() {\n      return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n  }, {\n    key: \"_derive\",\n    value: function _derive(index) {\n      if (index > 0xffffffff) {\n        throw new Error(\"invalid index - \" + String(index));\n      } // Base path\n\n\n      var path = this.path;\n\n      if (path) {\n        path += \"/\" + (index & ~HardenedBit);\n      }\n\n      var data = new Uint8Array(37);\n\n      if (index & HardenedBit) {\n        if (!this.privateKey) {\n          throw new Error(\"cannot derive child of neutered node\");\n        } // Data = 0x00 || ser_256(k_par)\n\n\n        data.set(arrayify(this.privateKey), 1); // Hardened path\n\n        if (path) {\n          path += \"'\";\n        }\n      } else {\n        // Data = ser_p(point(k_par))\n        data.set(arrayify(this.publicKey));\n      } // Data += ser_32(i)\n\n\n      for (var i = 24; i >= 0; i -= 8) {\n        data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n      }\n\n      var I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n      var IL = I.slice(0, 32);\n      var IR = I.slice(32); // The private key\n\n      var ki = null; // The public key\n\n      var Ki = null;\n\n      if (this.privateKey) {\n        ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n      } else {\n        var ek = new SigningKey(hexlify(IL));\n        Ki = ek._addPoint(this.publicKey);\n      }\n\n      var mnemonicOrPath = path;\n      var srcMnemonic = this.mnemonic;\n\n      if (srcMnemonic) {\n        mnemonicOrPath = Object.freeze({\n          phrase: srcMnemonic.phrase,\n          path: path,\n          locale: srcMnemonic.locale || \"en\"\n        });\n      }\n\n      return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n  }, {\n    key: \"derivePath\",\n    value: function derivePath(path) {\n      var components = path.split(\"/\");\n\n      if (components.length === 0 || components[0] === \"m\" && this.depth !== 0) {\n        throw new Error(\"invalid path - \" + path);\n      }\n\n      if (components[0] === \"m\") {\n        components.shift();\n      }\n\n      var result = this;\n\n      for (var i = 0; i < components.length; i++) {\n        var component = components[i];\n\n        if (component.match(/^[0-9]+'$/)) {\n          var index = parseInt(component.substring(0, component.length - 1));\n\n          if (index >= HardenedBit) {\n            throw new Error(\"invalid path index - \" + component);\n          }\n\n          result = result._derive(HardenedBit + index);\n        } else if (component.match(/^[0-9]+$/)) {\n          var _index = parseInt(component);\n\n          if (_index >= HardenedBit) {\n            throw new Error(\"invalid path index - \" + component);\n          }\n\n          result = result._derive(_index);\n        } else {\n          throw new Error(\"invalid path component - \" + component);\n        }\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"_fromSeed\",\n    value: function _fromSeed(seed, mnemonic) {\n      var seedArray = arrayify(seed);\n\n      if (seedArray.length < 16 || seedArray.length > 64) {\n        throw new Error(\"invalid seed\");\n      }\n\n      var I = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n      return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n  }, {\n    key: \"fromMnemonic\",\n    value: function fromMnemonic(mnemonic, password, wordlist) {\n      // If a locale name was passed in, find the associated wordlist\n      wordlist = getWordlist(wordlist); // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n\n      mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n      return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n        phrase: mnemonic,\n        path: \"m\",\n        locale: wordlist.locale\n      });\n    }\n  }, {\n    key: \"fromSeed\",\n    value: function fromSeed(seed) {\n      return HDNode._fromSeed(seed, null);\n    }\n  }, {\n    key: \"fromExtendedKey\",\n    value: function fromExtendedKey(extendedKey) {\n      var bytes = Base58.decode(extendedKey);\n\n      if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n        logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n      }\n\n      var depth = bytes[4];\n      var parentFingerprint = hexlify(bytes.slice(5, 9));\n      var index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n      var chainCode = hexlify(bytes.slice(13, 45));\n      var key = bytes.slice(45, 78);\n\n      switch (hexlify(bytes.slice(0, 4))) {\n        // Public Key\n        case \"0x0488b21e\":\n        case \"0x043587cf\":\n          return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n        // Private Key\n\n        case \"0x0488ade4\":\n        case \"0x04358394 \":\n          if (key[0] !== 0) {\n            break;\n          }\n\n          return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n      }\n\n      return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n  }]);\n\n  return HDNode;\n}();\nexport function mnemonicToSeed(mnemonic, password) {\n  if (!password) {\n    password = \"\";\n  }\n\n  var salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n  return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = getWordlist(wordlist);\n  logger.checkNormalize();\n  var words = wordlist.split(mnemonic);\n\n  if (words.length % 3 !== 0) {\n    throw new Error(\"invalid mnemonic\");\n  }\n\n  var entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n  var offset = 0;\n\n  for (var i = 0; i < words.length; i++) {\n    var index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n\n    if (index === -1) {\n      throw new Error(\"invalid mnemonic\");\n    }\n\n    for (var bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n\n      offset++;\n    }\n  }\n\n  var entropyBits = 32 * words.length / 3;\n  var checksumBits = words.length / 3;\n  var checksumMask = getUpperMask(checksumBits);\n  var checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error(\"invalid checksum\");\n  }\n\n  return hexlify(entropy.slice(0, entropyBits / 8));\n}\nexport function entropyToMnemonic(entropy, wordlist) {\n  wordlist = getWordlist(wordlist);\n  entropy = arrayify(entropy);\n\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error(\"invalid entropy\");\n  }\n\n  var indices = [0];\n  var remainingBits = 11;\n\n  for (var i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8; // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word\n\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  } // Compute the checksum bits\n\n\n  var checksumBits = entropy.length / 4;\n  var checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits); // Shift the checksum into the word indices\n\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n  return wordlist.join(indices.map(function (index) {\n    return wordlist.getWord(index);\n  }));\n}\nexport function isValidMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n    return true;\n  } catch (error) {}\n\n  return false;\n}\nexport function getAccountPath(index) {\n  if (typeof index !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n    logger.throwArgumentError(\"invalid account index\", \"index\", index);\n  }\n\n  return \"m/44'/60'/\".concat(index, \"'/0/0\");\n}","map":{"version":3,"sources":["/Users/vickykumarprasad/Desktop/chrome/ChromiumExtension/node_modules/@ethersproject/hdnode/src.ts/index.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\n\nimport { ExternallyOwnedAccount } from \"@ethersproject/abstract-signer\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { arrayify, BytesLike, concat, hexDataSlice, hexZeroPad, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { toUtf8Bytes, UnicodeNormalizationForm } from \"@ethersproject/strings\";\nimport { pbkdf2 } from \"@ethersproject/pbkdf2\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { computeHmac, ripemd160, sha256, SupportedAlgorithm } from \"@ethersproject/sha2\";\nimport { computeAddress } from \"@ethersproject/transactions\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst N = BigNumber.from(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = toUtf8Bytes(\"Bitcoin seed\");\n\nconst HardenedBit = 0x80000000;\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits);\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return (1 << bits) - 1;\n}\n\nfunction bytes32(value: BigNumber | Uint8Array): string {\n    return hexZeroPad(hexlify(value), 32);\n}\n\nfunction base58check(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nfunction getWordlist(wordlist: string | Wordlist): Wordlist {\n    if (wordlist == null) {\n        return wordlists[\"en\"];\n    }\n\n    if (typeof(wordlist) === \"string\") {\n        const words = wordlists[wordlist];\n        if (words == null) {\n            logger.throwArgumentError(\"unknown locale\", \"wordlist\", wordlist);\n        }\n        return words;\n    }\n\n    return wordlist;\n}\n\nconst _constructorGuard: any = {};\n\nexport const defaultPath = \"m/44'/60'/0'/0/0\";\n\nexport interface Mnemonic {\n    readonly phrase: string;\n    readonly path: string;\n    readonly locale: string;\n};\n\nexport class HDNode implements ExternallyOwnedAccount {\n    readonly privateKey: string;\n    readonly publicKey: string;\n\n    readonly fingerprint: string;\n    readonly parentFingerprint: string;\n\n    readonly address: string;\n\n    readonly mnemonic?: Mnemonic;\n    readonly path: string;\n\n    readonly chainCode: string;\n\n    readonly index: number;\n    readonly depth: number;\n\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string) {\n        logger.checkNew(new.target, HDNode);\n\n        /* istanbul ignore if */\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"HDNode constructor cannot be called directly\");\n        }\n\n        if (privateKey) {\n            const signingKey = new SigningKey(privateKey);\n            defineReadOnly(this, \"privateKey\", signingKey.privateKey);\n            defineReadOnly(this, \"publicKey\", signingKey.compressedPublicKey);\n        } else {\n            defineReadOnly(this, \"privateKey\", null);\n            defineReadOnly(this, \"publicKey\", hexlify(publicKey));\n        }\n\n        defineReadOnly(this, \"parentFingerprint\", parentFingerprint);\n        defineReadOnly(this, \"fingerprint\", hexDataSlice(ripemd160(sha256(this.publicKey)), 0, 4));\n\n        defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n        defineReadOnly(this, \"chainCode\", chainCode);\n\n        defineReadOnly(this, \"index\", index);\n        defineReadOnly(this, \"depth\", depth);\n\n        if (mnemonicOrPath == null) {\n            // From a source that does not preserve the path (e.g. extended keys)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", null);\n\n        } else if (typeof(mnemonicOrPath) === \"string\") {\n            // From a source that does not preserve the mnemonic (e.g. neutered)\n            defineReadOnly(this, \"mnemonic\", null);\n            defineReadOnly(this, \"path\", mnemonicOrPath);\n\n        } else {\n            // From a fully qualified source\n            defineReadOnly(this, \"mnemonic\", mnemonicOrPath);\n            defineReadOnly(this, \"path\", mnemonicOrPath.path);\n        }\n    }\n\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        if (this.depth >= 256) { throw new Error(\"Depth too large!\"); }\n\n        return base58check(concat([\n            ((this.privateKey != null) ? \"0x0488ADE4\": \"0x0488B21E\"),\n            hexlify(this.depth),\n            this.parentFingerprint,\n            hexZeroPad(hexlify(this.index), 4),\n            this.chainCode,\n            ((this.privateKey != null) ? concat([ \"0x00\", this.privateKey ]): this.publicKey),\n        ]));\n    }\n\n    neuter(): HDNode {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n    }\n\n    private _derive(index: number): HDNode {\n        if (index > 0xffffffff) { throw new Error(\"invalid index - \" + String(index)); }\n\n        // Base path\n        let path = this.path;\n        if (path) { path += \"/\" + (index & ~HardenedBit); }\n\n        const data = new Uint8Array(37);\n\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error(\"cannot derive child of neutered node\");\n            }\n\n            // Data = 0x00 || ser_256(k_par)\n            data.set(arrayify(this.privateKey), 1);\n\n            // Hardened path\n            if (path) { path += \"'\"; }\n\n        } else {\n            // Data = ser_p(point(k_par))\n            data.set(arrayify(this.publicKey));\n        }\n\n        // Data += ser_32(i)\n        for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n\n        const I = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data));\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n\n        // The private key\n        let ki: string = null\n\n        // The public key\n        let Ki: string = null;\n\n        if (this.privateKey) {\n            ki = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N));\n        } else {\n            const ek = new SigningKey(hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n\n        let mnemonicOrPath: Mnemonic | string = path;\n\n        const srcMnemonic =  this.mnemonic;\n        if (srcMnemonic) {\n            mnemonicOrPath = Object.freeze({\n                phrase: srcMnemonic.phrase,\n                path: path,\n                locale: (srcMnemonic.locale || \"en\")\n            });\n        }\n\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n    }\n\n    derivePath(path: string): HDNode {\n        const components = path.split(\"/\");\n\n        if (components.length === 0 || (components[0] === \"m\" && this.depth !== 0)) {\n            throw new Error(\"invalid path - \" + path);\n        }\n\n        if (components[0] === \"m\") { components.shift(); }\n\n        let result: HDNode = this;\n        for (let i = 0; i < components.length; i++) {\n            const component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                const index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(HardenedBit + index);\n            } else if (component.match(/^[0-9]+$/)) {\n                const index = parseInt(component);\n                if (index >= HardenedBit) { throw new Error(\"invalid path index - \" + component); }\n                result = result._derive(index);\n            } else {\n                throw new Error(\"invalid path component - \" + component);\n            }\n        }\n\n        return result;\n    }\n\n\n    static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode {\n        const seedArray: Uint8Array = arrayify(seed);\n        if (seedArray.length < 16 || seedArray.length > 64) { throw new Error(\"invalid seed\"); }\n\n        const I: Uint8Array = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\n        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic);\n    }\n\n    static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode {\n\n        // If a locale name was passed in, find the associated wordlist\n        wordlist = getWordlist(wordlist);\n\n        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\n        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n            phrase: mnemonic,\n            path: \"m\",\n            locale: wordlist.locale\n        });\n    }\n\n    static fromSeed(seed: BytesLike): HDNode {\n        return HDNode._fromSeed(seed, null);\n    }\n\n    static fromExtendedKey(extendedKey: string): HDNode {\n        const bytes = Base58.decode(extendedKey);\n\n        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n            logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n        }\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\":\n                return new HDNode(_constructorGuard, null, hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNode(_constructorGuard, hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n        }\n\n        return logger.throwArgumentError(\"invalid extended key\", \"extendedKey\", \"[REDACTED]\");\n    }\n}\n\nexport function mnemonicToSeed(mnemonic: string, password?: string): string {\n    if (!password) { password = \"\"; }\n\n    const salt = toUtf8Bytes(\"mnemonic\" + password, UnicodeNormalizationForm.NFKD);\n\n    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, \"sha512\");\n}\n\nexport function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    logger.checkNormalize();\n\n    const words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) { throw new Error(\"invalid mnemonic\"); }\n\n    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        if (index === -1) { throw new Error(\"invalid mnemonic\"); }\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = arrayify(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error(\"invalid checksum\");\n    }\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexport function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string {\n    wordlist = getWordlist(wordlist);\n\n    entropy = arrayify(entropy);\n\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error(\"invalid entropy\");\n    }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = arrayify(sha256(entropy))[0] & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nexport function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    } catch (error) { }\n    return false;\n}\n\nexport function getAccountPath(index: number): string {\n    if (typeof(index) !== \"number\" || index < 0 || index >= HardenedBit || index % 1) {\n        logger.throwArgumentError(\"invalid account index\", \"index\", index);\n    }\n    return `m/44'/60'/${ index }'/0/0`;\n}\n"]},"metadata":{},"sourceType":"module"}